(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{194:function(t,r,n){"use strict";n.r(r);var s=n(0),e=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,r=t.$createElement,n=t._self._c||r;return n("div",{staticClass:"content"},[n("h3",{attrs:{id:"js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js","aria-hidden":"true"}},[t._v("#")]),t._v(" js")]),t._v(" "),n("h4",{attrs:{id:"数组的操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组的操作","aria-hidden":"true"}},[t._v("#")]),t._v(" 数组的操作")]),t._v(" "),n("p",[t._v("数组去重")]),t._v(" "),n("h4",{attrs:{id:"深拷贝和浅拷贝：json-parse-json-stringify-obj-深拷贝的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝：json-parse-json-stringify-obj-深拷贝的问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 深拷贝和浅拷贝：JSON.parse(JSON.stringify(obj))深拷贝的问题")]),t._v(" "),n("p",[t._v("递归\n1、如果obj里面存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。\n2、如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象。\n3、如果obj里有函数，undefined，则序列化的结果会把函数， undefined丢失。\n4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。\n5、JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor。\n6、如果对象中存在循环引用的情况也无法正确实现深拷贝")]),t._v(" "),n("h4",{attrs:{id:"原型，原型链，继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型，原型链，继承","aria-hidden":"true"}},[t._v("#")]),t._v(" 原型，原型链，继承")]),t._v(" "),n("p",[t._v("可以将js中的对象分为普通对象和函数对象"),n("br"),t._v("\nprototype原型对象只有在函数对象中有，prototype原型对象的作用是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.proto===Foo.prototype"),n("br"),t._v("\n每个对象都有_proto_原型链这个内置属性，它的作用就是指向创建它的构造函数的原型对象"),n("br"),t._v("\n当访问一个对象的属性时，如果该对象内部不存在这个属性，那么它就会去_proto_属性所指向的那个对象，也就是父对象上找，一直找，直到_proto_属性的终点为null，然后返回undefined，通过_proto_属性将对象连接起来的这条链路就叫原型链")]),t._v(" "),n("p",[t._v("圣杯模式")])])}],!1,null,null,null);r.default=e.exports}}]);