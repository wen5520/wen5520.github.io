(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{208:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,a=t._self._c;return a("div",{staticClass:"content"},[a("h3",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue")]),t._v(" "),a("h4",{attrs:{id:"数据双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据双向绑定"}},[t._v("#")]),t._v(" 数据双向绑定")]),t._v(" "),a("p",[t._v("Vue 实现 双向数据绑定 主要采用："),a("strong",[t._v("数据劫持结合“发布-订阅”模式的方式，通过Object.defineProperty（）的 set 和 get，在数据变动时发布消息给订阅者触发监听。")])]),t._v(" "),a("h4",{attrs:{id:"对mvvm的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对mvvm的理解"}},[t._v("#")]),t._v(" 对MVVM的理解")]),t._v(" "),a("p",[t._v("传统的MVC是用户操作请求服务器端路由，路由会调用对应的控制器来处理，，控制器会获取数据，将结果返回给前端，也买你重新渲染。\n"),a("code",[t._v("MVVM")]),t._v("是在传统的MVC的基础上，新增了ViewModule\n页面　数据　数据控制层")]),t._v(" "),a("h4",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("h4",{attrs:{id:"vue的api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的api"}},[t._v("#")]),t._v(" vue的API")]),t._v(" "),a("h4",{attrs:{id:"v-modle的作用及原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-modle的作用及原理"}},[t._v("#")]),t._v(" v-modle的作用及原理")]),t._v(" "),a("h4",{attrs:{id:"v-for-的key值，作用和相同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-for-的key值，作用和相同"}},[t._v("#")]),t._v(" v-for 的key值，作用和相同")]),t._v(" "),a("h4",{attrs:{id:"vue-url带-和不带-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-url带-和不带-的区别"}},[t._v("#")]),t._v(" vue url带#和不带#的区别")]),t._v(" "),a("h4",{attrs:{id:"vie一进入做了什么，init"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vie一进入做了什么，init"}},[t._v("#")]),t._v(" vie一进入做了什么，init()")])])}],!1,null,null,null);a.default=s.exports}}]);